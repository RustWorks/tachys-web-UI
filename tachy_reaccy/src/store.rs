use crate::{
    prelude::{ArcRwSignal, SignalSet},
    source::Track,
};
use parking_lot::{
    MappedRwLockReadGuard, MappedRwLockWriteGuard, RwLock, RwLockReadGuard,
    RwLockWriteGuard,
};
use rustc_hash::FxHashMap;
use std::{
    any::Any,
    cell::RefCell,
    collections::HashSet,
    hash::Hash,
    mem,
    ops::{Deref, DerefMut},
    panic::Location,
    path::Path,
    sync::Arc,
};

pub struct ArcStore<T> {
    #[cfg(debug_assertions)]
    defined_at: &'static Location<'static>,
    pub(crate) value: Arc<RwLock<T>>,
    //inner: Arc<RwLock<SubscriberSet>>,
    signals: Arc<RwLock<FxHashMap<Vec<StorePath>, ArcRwSignal<()>>>>,
}

impl<T> Clone for ArcStore<T> {
    fn clone(&self) -> Self {
        Self {
            #[cfg(debug_assertions)]
            defined_at: self.defined_at,
            value: Arc::clone(&self.value),
            signals: Arc::clone(&self.signals),
        }
    }
}

#[derive(Debug, PartialEq, Eq)]
pub struct StoreField<T>(T);

impl<T> Deref for StoreField<T> {
    type Target = T;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl<T> DerefMut for StoreField<T> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}

impl<T> StoreField<&Vec<T>> {
    pub fn at(&self, index: usize) -> StoreField<Option<&T>> {
        Store::add_to_path(index);
        StoreField(self.get(index))
    }
}

impl<T> StoreField<&mut Vec<T>> {
    pub fn at_mut(&mut self, index: usize) -> StoreField<Option<&mut T>> {
        Store::add_to_path(index);
        StoreField(self.get_mut(index))
    }
}

#[derive(Debug)]
struct StorePath {
    segment: usize,
    update: bool,
}

impl PartialEq for StorePath {
    fn eq(&self, other: &Self) -> bool {
        self.segment == other.segment
    }
}

impl Eq for StorePath {}

impl Hash for StorePath {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        self.segment.hash(state);
    }
}

thread_local! {
    static STORE_PATH_BUILDER: RefCell<Vec<StorePath>> = RefCell::new(Vec::new());
}

pub struct Store {}

impl Store {
    pub fn add_to_path(segment: usize) {
        STORE_PATH_BUILDER.with(|path| {
            path.borrow_mut().push(StorePath {
                segment,
                update: false,
            });
        });
    }

    pub fn update_at_path(segment: usize) {
        STORE_PATH_BUILDER.with(|path| {
            path.borrow_mut().push(StorePath {
                segment,
                update: true,
            });
        });
    }

    fn take_path() -> Vec<StorePath> {
        STORE_PATH_BUILDER.with(|path| mem::take(&mut *path.borrow_mut()))
    }
}

impl<T> ArcStore<T> {
    #[cfg_attr(
        feature = "tracing",
        tracing::instrument(level = "trace", skip_all,)
    )]
    pub fn new(value: T) -> Self {
        Self {
            #[cfg(debug_assertions)]
            defined_at: Location::caller(),
            value: Arc::new(RwLock::new(value)),
            signals: Default::default(),
            /* inner: Arc::new(RwLock::new(SubscriberSet::new())), */
        }
    }

    pub fn with<U>(&self, fun: impl FnOnce(&T) -> U) -> U {
        let guard = self.value.read();
        let value = fun(&*guard);
        // get the path that was generated by touching all the nodes
        let path = Store::take_path();
        let mut signals = self.signals.write();
        let signal =
            signals.entry(path).or_insert_with(|| ArcRwSignal::new(()));
        signal.track();
        value
    }

    pub fn update<U>(&self, fun: impl FnOnce(&mut T) -> U) -> U {
        let mut guard = self.value.write();
        let value = fun(&mut *guard);
        // get the path that was generated by touching all the nodes
        let path = Store::take_path();
        let mut signals = self.signals.write();
        let signal =
            signals.entry(path).or_insert_with(|| ArcRwSignal::new(()));
        signal.set(());
        value
    }

    pub fn at_value_untracked<U>(
        &self,
        fun: impl FnOnce(&T) -> &U,
    ) -> MappedRwLockReadGuard<'_, U> {
        let guard = self.value.read();
        RwLockReadGuard::map(guard, |value| fun(value))
    }

    pub fn at_value_mut<U>(
        &self,
        fun: impl FnOnce(&mut T) -> &mut U,
    ) -> MappedRwLockWriteGuard<'_, U> {
        let guard = self.value.write();
        RwLockWriteGuard::map(guard, |value| fun(value))
    }
}

#[cfg(test)]
mod tests {
    use super::{ArcStore, Store, StoreField};
    use crate::effect::Effect;
    use parking_lot::RwLock;
    use std::{mem, sync::Arc};

    pub async fn tick() {
        tokio::time::sleep(std::time::Duration::from_micros(1)).await;
    }

    #[derive(Debug)]
    struct Todos {
        user: String,
        todos: Vec<Todo>,
    }

    // macro expansion
    impl Todos {
        pub fn user(&self) -> StoreField<&String> {
            Store::add_to_path(Todos::user as usize);
            StoreField(&self.user)
        }

        pub fn set_user(&mut self, value: impl Into<String>) {
            Store::update_at_path(Todos::user as usize);
            self.user = value.into();
        }

        pub fn update_user(&mut self) -> StoreField<&mut String> {
            Store::update_at_path(Todos::user as usize);
            StoreField(&mut self.user)
        }

        pub fn todos(&self) -> StoreField<&Vec<Todo>> {
            Store::add_to_path(Todos::todos as usize);
            StoreField(&self.todos)
        }

        pub fn todos_mut(&mut self) -> StoreField<&mut Vec<Todo>> {
            Store::add_to_path(Todos::todos as usize);
            StoreField(&mut self.todos)
        }

        pub fn set_todos(&mut self, value: impl Into<Vec<Todo>>) {
            Store::update_at_path(Todos::todos as usize);
            self.todos = value.into();
        }

        pub fn update_todos(&mut self) -> StoreField<&mut Vec<Todo>> {
            Store::update_at_path(Todos::todos as usize);
            StoreField(&mut self.todos)
        }
    }
    // end macro expansion

    #[derive(Debug)]
    struct Todo {
        label: String,
        completed: bool,
    }

    // macro expansion
    impl Todo {
        pub fn label(&self) -> StoreField<&String> {
            Store::add_to_path(Todo::label as usize);
            StoreField(&self.label)
        }

        pub fn update_label(&mut self) -> &mut String {
            Store::update_at_path(Todo::label as usize);
            &mut self.label
        }

        pub fn set_label(&mut self, value: impl Into<String>) {
            Store::update_at_path(Todo::label as usize);
            self.label = value.into();
        }

        pub fn completed(&self) -> StoreField<&bool> {
            Store::add_to_path(Todo::completed as usize);
            StoreField(&self.completed)
        }

        pub fn update_completed(&mut self) -> StoreField<&mut bool> {
            Store::update_at_path(Todo::completed as usize);
            StoreField(&mut self.completed)
        }

        pub fn set_completed(&mut self, value: impl Into<bool>) {
            Store::update_at_path(Todo::completed as usize);
            self.completed = value.into();
        }
    }
    // end macro expansion

    fn data() -> Todos {
        Todos {
            user: "Bob".to_string(),
            todos: vec![
                Todo {
                    label: "Create reactive store".to_string(),
                    completed: true,
                },
                Todo {
                    label: "???".to_string(),
                    completed: false,
                },
                Todo {
                    label: "Profit".to_string(),
                    completed: false,
                },
            ],
        }
    }

    #[tokio::test]
    async fn mutating_store_field_triggers_effect() {
        let combined_count = Arc::new(RwLock::new(0));

        let store = ArcStore::new(data());
        mem::forget(Effect::new_sync({
            let store = store.clone();
            let combined_count = Arc::clone(&combined_count);
            move |prev| {
                if prev.is_none() {
                    println!("first run");
                } else {
                    println!("next run");
                }
                store.with(|data| println!("{:?}", data.user()));
                *combined_count.write() += 1;
            }
        }));
        tick().await;
        store.update(|data| data.set_user("Tom"));
        tick().await;
        store.update(|data| data.set_user("Carol"));
        tick().await;
        store.update(|data| data.update_user().push_str("!!!"));
        tick().await;
        assert_eq!(*combined_count.read(), 4);
    }

    #[tokio::test]
    async fn mutating_store_doesnt_trigger_other_fields() {
        let combined_count = Arc::new(RwLock::new(0));

        let store = ArcStore::new(data());
        mem::forget(Effect::new_sync({
            let store = store.clone();
            let combined_count = Arc::clone(&combined_count);
            move |prev| {
                if prev.is_none() {
                    println!("first run");
                } else {
                    panic!("shouldn't rerun")
                }
                store.with(|data| println!("{:?}", data.todos()));
                *combined_count.write() += 1;
            }
        }));
        tick().await;
        store.update(|data| data.set_user("Tom"));
        tick().await;
        store.update(|data| data.update_user().push_str("!!!"));
        tick().await;
        assert_eq!(*combined_count.read(), 1);
    }

    #[tokio::test]
    async fn mutating_vec_field_updates_inner_only() {
        let combined_count = Arc::new(RwLock::new(0));

        let store = ArcStore::new(data());
        mem::forget(Effect::new_sync({
            let store = store.clone();
            let combined_count = Arc::clone(&combined_count);
            move |prev| {
                store.with(|data| {
                    println!("{:?}", data.todos().at(1).map(|n| n.label()))
                });
                *combined_count.write() += 1;
            }
        }));
        tick().await;
        store.update(|data| data.set_user("Greg"));
        tick().await;
        store.update(|data| {
            data.update_todos().push(Todo {
                label: "Another one".into(),
                completed: false,
            });
        });
        tick().await;
        store.update(|data| {
            data.todos_mut()
                .at_mut(1)
                .as_mut()
                .map(|n| n.set_label("Fine-grained updates!"))
        });
        tick().await;
        store.update(|data| {
            data.todos_mut()
                .at_mut(2)
                .as_mut()
                .map(|n| n.set_label("Profit??"))
        });
        tick().await;
        assert_eq!(*combined_count.read(), 2);
    }
}
