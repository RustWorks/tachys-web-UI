use crate::{
    prelude::{ArcRwSignal, SignalSet},
    source::Track,
};
use parking_lot::{
    MappedRwLockReadGuard, MappedRwLockWriteGuard, RwLock, RwLockReadGuard,
    RwLockWriteGuard,
};
use rustc_hash::FxHashMap;
use std::{
    any::Any, cell::RefCell, collections::HashSet, hash::Hash, mem,
    panic::Location, path::Path, sync::Arc,
};

pub struct ArcStore<T> {
    #[cfg(debug_assertions)]
    defined_at: &'static Location<'static>,
    pub(crate) value: Arc<RwLock<T>>,
    //inner: Arc<RwLock<SubscriberSet>>,
    signals: Arc<RwLock<FxHashMap<Vec<StorePath>, ArcRwSignal<()>>>>,
}

impl<T> Clone for ArcStore<T> {
    fn clone(&self) -> Self {
        Self {
            #[cfg(debug_assertions)]
            defined_at: self.defined_at,
            value: Arc::clone(&self.value),
            signals: Arc::clone(&self.signals),
        }
    }
}

#[derive(Debug)]
struct StorePath {
    segment: usize,
    update: bool,
}

impl PartialEq for StorePath {
    fn eq(&self, other: &Self) -> bool {
        self.segment == other.segment
    }
}

impl Eq for StorePath {}

impl Hash for StorePath {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        self.segment.hash(state);
    }
}

thread_local! {
    static STORE_PATH_BUILDER: RefCell<Vec<StorePath>> = RefCell::new(Vec::new());
}

pub struct Store {}

impl Store {
    pub fn add_to_path(segment: usize) {
        STORE_PATH_BUILDER.with(|path| {
            path.borrow_mut().push(StorePath {
                segment,
                update: false,
            })
        });
    }

    pub fn update_at_path(segment: usize) {
        STORE_PATH_BUILDER.with(|path| {
            path.borrow_mut().push(StorePath {
                segment,
                update: true,
            })
        });
    }

    fn take_path() -> Vec<StorePath> {
        STORE_PATH_BUILDER.with(|path| mem::take(&mut *path.borrow_mut()))
    }
}

impl<T> ArcStore<T> {
    #[cfg_attr(
        feature = "tracing",
        tracing::instrument(level = "trace", skip_all,)
    )]
    pub fn new(value: T) -> Self {
        Self {
            #[cfg(debug_assertions)]
            defined_at: Location::caller(),
            value: Arc::new(RwLock::new(value)),
            signals: Default::default(),
            /* inner: Arc::new(RwLock::new(SubscriberSet::new())), */
        }
    }

    pub fn with<U>(&self, fun: impl FnOnce(&T) -> U) -> U {
        let guard = self.value.read();
        let value = fun(&*guard);
        // get the path that was generated by touching all the nodes
        let path = Store::take_path();
        let mut signals = self.signals.write();
        let signal =
            signals.entry(path).or_insert_with(|| ArcRwSignal::new(()));
        signal.track();
        value
    }

    pub fn update<U>(&self, fun: impl FnOnce(&mut T) -> U) -> U {
        let mut guard = self.value.write();
        let value = fun(&mut *guard);
        // get the path that was generated by touching all the nodes
        let path = Store::take_path();
        let mut signals = self.signals.write();
        let signal =
            signals.entry(path).or_insert_with(|| ArcRwSignal::new(()));
        signal.set(());
        value
    }

    fn at_raw<U>(
        &self,
        fun: impl FnOnce(&T) -> &U,
    ) -> (Vec<StorePath>, MappedRwLockReadGuard<'_, U>) {
        let guard = self.value.read();
        let f = RwLockReadGuard::map(guard, |value| fun(value));
        // get the path that was generated by touching all the nodes
        let path = Store::take_path();
        (path, f)
    }

    fn at_mut_raw<U>(
        &self,
        fun: impl FnOnce(&mut T) -> &mut U,
    ) -> (Vec<StorePath>, MappedRwLockWriteGuard<'_, U>) {
        let guard = self.value.write();
        let f = RwLockWriteGuard::map(guard, |value| fun(value));
        // get the path that was generated by touching all the nodes
        let path = Store::take_path();
        (path, f)
    }

    pub fn at_value_untracked<U>(
        &self,
        fun: impl FnOnce(&T) -> &U,
    ) -> MappedRwLockReadGuard<'_, U> {
        let guard = self.value.read();
        RwLockReadGuard::map(guard, |value| fun(value))
    }

    pub fn at_value_mut<U>(
        &self,
        fun: impl FnOnce(&mut T) -> &mut U,
    ) -> MappedRwLockWriteGuard<'_, U> {
        let guard = self.value.write();
        RwLockWriteGuard::map(guard, |value| fun(value))
    }
}

#[cfg(test)]
mod tests {
    use super::{ArcStore, Store};
    use crate::effect::Effect;
    use parking_lot::RwLock;
    use std::{mem, sync::Arc};

    pub async fn tick() {
        tokio::time::sleep(std::time::Duration::from_micros(1)).await;
    }

    #[derive(Debug)]
    struct Todos {
        user: String,
        todos: Vec<Todo>,
    }

    // macro expansion
    impl Todos {
        pub fn user(&self) -> &String {
            Store::add_to_path(Todos::user as usize);
            &self.user
        }

        pub fn set_user(&mut self, value: impl Into<String>) {
            Store::update_at_path(Todos::user as usize);
            self.user = value.into();
        }

        pub fn update_user(&mut self) -> &mut String {
            Store::update_at_path(Todos::user as usize);
            &mut self.user
        }

        pub fn todos(&self) -> &Vec<Todo> {
            Store::add_to_path(Todos::todos as usize);
            &self.todos
        }

        pub fn set_todos(&mut self, value: impl Into<Vec<Todo>>) {
            Store::update_at_path(Todos::todos as usize);
            self.todos = value.into();
        }

        pub fn update_todos(&mut self) -> &mut Vec<Todo> {
            Store::update_at_path(Todos::todos as usize);
            &mut self.todos
        }
    }
    // end macro expansion

    #[derive(Debug)]
    struct Todo {
        label: String,
        completed: bool,
    }

    // macro expansion
    impl Todo {
        pub fn label(&self) -> &String {
            &self.label
        }

        pub fn update_label(&mut self) -> &mut String {
            &mut self.label
        }

        pub fn completed(&self) -> &bool {
            &self.completed
        }

        pub fn update_completed(&mut self) -> &mut bool {
            &mut self.completed
        }
    }
    // end macro expansion

    fn data() -> Todos {
        Todos {
            user: "Bob".to_string(),
            todos: vec![
                Todo {
                    label: "Create reactive store".to_string(),
                    completed: true,
                },
                Todo {
                    label: "???".to_string(),
                    completed: false,
                },
                Todo {
                    label: "Profit".to_string(),
                    completed: false,
                },
            ],
        }
    }

    #[test]
    fn access_store_fields() {
        let store = ArcStore::new(data());
        assert_eq!(&*store.at_value_untracked(|data| data.user()), "Bob");
        assert_eq!(store.at_value_untracked(|data| data.todos()).len(), 3);
    }

    #[test]
    fn update_store_fields() {
        let store = ArcStore::new(data());
        assert_eq!(&*store.at_value_untracked(|data| data.user()), "Bob");
        store
            .at_value_mut(|data| data.update_user())
            .push_str("!!!");
        assert_eq!(
            &*store.at_value_untracked(|data| data.user() /*  */),
            "Bob!!!"
        );
    }

    #[test]
    fn mutate_value() {
        let store = ArcStore::new(data());
        let (read_path, data) = store.at_raw(|data| data.user());
        assert_eq!(&*data, "Bob");
        drop(data);
        let (write_path, mut data) =
            store.at_mut_raw(|data| data.update_user());
        data.push_str("!!!");
        assert_eq!(read_path, write_path);
    }

    #[tokio::test]
    async fn mutating_store_field_triggers_effect() {
        let combined_count = Arc::new(RwLock::new(0));

        let store = ArcStore::new(data());
        mem::forget(Effect::new_sync({
            let store = store.clone();
            let combined_count = Arc::clone(&combined_count);
            move |prev| {
                if prev.is_none() {
                    println!("first run");
                } else {
                    println!("next run");
                }
                store.with(|data| println!("{:?}", data.user()));
                *combined_count.write() += 1;
            }
        }));
        tick().await;
        store.update(|data| data.set_user("Tom"));
        tick().await;
        store.update(|data| data.set_user("Carol"));
        tick().await;
        store.update(|data| data.update_user().push_str("!!!"));
        tick().await;
        assert_eq!(*combined_count.read(), 4);
    }

    #[tokio::test]
    async fn mutating_store_doesnt_trigger_other_fields() {
        let combined_count = Arc::new(RwLock::new(0));

        let store = ArcStore::new(data());
        mem::forget(Effect::new_sync({
            let store = store.clone();
            let combined_count = Arc::clone(&combined_count);
            move |prev| {
                if prev.is_none() {
                    println!("first run");
                } else {
                    panic!("shouldn't rerun")
                }
                store.with(|data| println!("{:?}", data.todos()));
                *combined_count.write() += 1;
            }
        }));
        tick().await;
        store.update(|data| data.set_user("Tom"));
        tick().await;
        store.update(|data| data.update_user().push_str("!!!"));
        tick().await;
        assert_eq!(*combined_count.read(), 1);
    }
}
